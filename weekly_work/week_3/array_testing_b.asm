; p21
; yasm -g dwarf2 -f elf64 -o array3.o array3.asm
; gcc array3.o /home/netw7006/code_libraries/libasm_io-master/bin/libasm_io.a -no-pie -o array3


%include "/home/malware/asm/joey_lib_io_v6_release.asm"

global main

; p22
section .data
	
	echo_welcome: db	"Hello, this is a student ID storage programme",0
	echo_instruction: db "Please enter a student ID: ",0
	echo_message: db "A valid ID is :",0
	echo_bye:	db	"Goodbye!",0
	counter:		dq	0				; a loop counter
	characters:	times 90 db 0		; an array big enough for 10 student IDs (8 chars + null)

; p23
section .text

	; This is our procedure for reading the IDs
	populate:
		lea rbx, [characters]
		mov QWORD  [counter],  0
		loop1:
			mov rdi, QWORD echo_instruction
			call print_string_new
			call print_nl_new
			call read_string_new
; p24
            ; We can't move a memory address to another memory address using mov so we use rcx to store the address
			mov rcx,[rax]
			mov [rbx], rcx
			add rbx,9
			add QWORD [counter],9
			cmp QWORD [counter], 27
			jne loop1
            ret

    ; This prints them out
	display:
		loop2:
			mov rdi, QWORD echo_message
			call print_string_new
			; set rdi to be the start of the buffer
			mov rdi,  characters
			; and add the number of bytes to get to the current record
			add rdi, rbx
			call print_string_new
			call print_nl_new
			add rbx,9
			cmp rbx, 27
			jne loop2
            ret

; p27
    main:
    mov rbp, rsp; for correct debugging
		push rbp
		mov rbp, rsp
		sub rsp,32

		mov rdi, QWORD echo_welcome
		call print_string_new
		call print_nl_new

		call populate
		sub rbx,rbx
		call display
; p28
        mov rdi, QWORD echo_bye
		call print_string_new
		call print_nl_new

		add rsp, 32

		pop rbp

		ret
