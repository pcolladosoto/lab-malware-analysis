# Inspecting the contents of the SPL register
We should begin by knowing that `SPL` is not actually a register. With that term we are actually referring to the `8 LSs` or `8 Least Significant Bits` of the proper stack pointer register which is none other than `RSP` when referring to all its `64 bits` (remember we are dealing with a `64` bit architecture).

From the above we can see how inspecting the value of `SPL` is actually equivalent to observing the last two `nibbles` or the last `byte` in the `RSP` register which is the one we can easily watch within `SASM` and `gdb`. In doing so and given our `asm` source code file we see how there are `4` instructions that will modify it. We'll break them down now:

1. `push rbp` -> This saves the *Stack Base Pointer*, `RBP` into the stack so that it can later be retrieved. Now, note how pushing something into the stack is going to alter the stack pointer so that we can then push new stuff into it. Knowing what we have in the stack pointer is just an address we can actually make some assumptions about how the stack works. Taking into account that the initial address we had was `0x7fffffffe5e8` and that, after pushing `RBP` it became `0x7fffffffe5e0` we can state that:
	+ The stack is descending, that is, it grows towards **lower** addresses because pushing stuff into it will decrease the stack pointer's value.
	+ We can't nonetheless know whether the stack is full or empty in the sense that we don't know if the stack pointer points to the last element in the stack or to the next empty stack location.
	+ The value of the `SPL` register changed by 8 units or `bytes` (addresses refer to individual `bytes`) which is exactly `64 bits`, the size of the register we just pushed into the stack. The value itself went from `0xE8` to `0xE0``.

2. `sub rsp, 32` ->  After pushing `rbp` we are also subtracting `32` from the stack pointer itself. `Knowing `32 = 0x20` we can expect the new value inside `RSP` to be `0x7fffffffe5c0`. Again, the value of `SPL` went from `0xE0` to `0xC0`.

3. `add rsp, 32` -> Using the same logic as before we see how the value of `SPL` changes from `0xC0` to `0xE0`.

4. `pop rbp` -> By "poping" a value from the stack into `RBP` we are in effect emptying it which will make the stack pointer's value increase because, as we said, this is a descending stack that grows towards low addresses which, in turn, is equivalent to diminishing towards the high ones. In the end we can see how the value of `SPL` will change from `0xE0` back to `0xE8`. Note that having the stack pointer with the same value than at the beginning of the `main` subroutine is no coincidence whatsoever!

