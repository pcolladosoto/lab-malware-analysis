; Multiplication program to study the use of the 'jo' instruction

%include "../../../libs/io_v6.asm"

global main
section .data

overflw_msg: db "The result caused an overflow...", 0x0
result:  db "The result is -> ", 0x0

section .text

main:
    push rbp
    mov rbp, rsp
    sub rsp,32

    ; Remember R[]X registers are 64 bit already!
    ; That's why we only need to check RAX's value, we don't need to mess around with two registers

    ; The following combination will NOT cause an overflow
    ; mov rax, 0xFF
    ; mov rbx, 0xA

    ; The following combination will INDEED cause an overflow
    mov rax, 0x7FFFFFFFFFFFFFFF
    mov rbx, 0xFFFF


    mul rbx

    ; Just jump if the overflow flag is set
    jo .overflw

    ; Remember 'print_string_new' will NOT respect our registers... we'd better save the result
    push rax

    ; Load up the message to ask for a number
    mov rdi, QWORD result
    call print_string_new
    pop rdi
    call print_int_new
    call print_nl_new
    jmp .end

.overflw:
    mov rdi, QWORD overflw_msg
    call print_string_new
    call print_nl_new
    xor rax, rax
    jmp .end

.end:
    add rsp, 32
    pop rbp

    ret