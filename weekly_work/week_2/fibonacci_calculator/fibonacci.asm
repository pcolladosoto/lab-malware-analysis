; Fibonacci Series ASM Calculator

; Docker environment include
; %include "/mw_repo/libs/io_v6.asm"

; Lubuntu VM include
%include "/home/malware/asm/joey_lib_io_v6_release.asm"

global main

section .data

MAX_INDEX equ 1000
TARGET_INDEX equ 10

welcome_msg: db "Index to compute -> ", 0x0
too_big_msg: db "The requested index MUST be smaller than 1000!", 0x0
result_msga: db "Index ", 0x0
result_msgb: db " of the Fibonacci series is -> ", 0x0

section .text

main:
    ; Set up main's stack frame
    push rbp
    mov rbp, rsp
    sub rsp,32

    ; Welcome the user and ask for input!
    mov rdi, QWORD welcome_msg
    call print_string_new
    call read_int_new

    ; If we are to hardcode the value just use the following
    ; and change the value of TARGET_INDEX.
    ; You can leave the above block uncommented or comment it out.
    ; It'll work either way but, as always, the most efficient
    ; approach is to indeed comment it out
    ; mov rax, TARGET_INDEX

    ; Term n of the Fibonacci series is computed as:
        ; T_n = T_{n - 1} + T_{n - 2}
        ; Taken from -> https://en.wikipedia.org/wiki/Fibonacci_number

    ; Register breakdown:
        ; RAX -> The target index to compute. Remember that's where 'read_int_new' returns the read value!
        ; RBX -> Lower index value of the two needed for computing the series (a.k.a T_{n - 2})
        ; RCX -> Higher index value of the two needed for computing the series (a.k.a T_{n - 1})
        ; RDX -> Loop counter

    ; Initialize the used registers:
        ; RBX -> The first element in the series is 0 by definition
        ; RCX -> The second element in the series is 1 by definition
        ; RDX -> As we are printing indexes 0 and 1 without going into the loop
                ; we need to compensate for that fact by initializing the loop count
                ; to 1 as if we reach the loop it's as if we had already computed one
                ; element!
    xor rbx, rcx
    mov rcx, 0x1
    mov rdx, 0x1

    ; If the index is 0 or 1 just print the values we initialized the registers with
    cmp rax, 0
    je .print_result

    cmp rax, 1
    je .ione

    ; If the requested index is too big print an error message and exit
    cmp rax, MAX_INDEX
    jge .too_big

.loop:
    ; Otherwise we'll fall through the main loop!
    add rbx, rcx
    xchg rbx, rcx
    inc rdx
    cmp rax, rdx
    je .ione
    jmp .loop

.ione:
    ; As we expect the result on RBX we'll just swap these out if asked for index 1
    xchg rbx, rcx

.print_result:
    ; The result is passed on RBX and the index we computed is still on RAX.
    ; We'll push them to the stack so that they're safe from the calls to the
    ; I/O functions and pop them where appropriate to build the correct outut.
    push rbx
    push rax

    ; Print all the result messages
    mov rdi, QWORD result_msga
    call print_string_new
    pop rdi
    call print_int_new
    mov rdi, QWORD result_msgb
    call print_string_new
    pop rdi
    call print_int_new
    call print_nl_new
    jmp .end

.too_big:
    ; Just print an error message and quit
    mov rdi, QWORD too_big_msg
    call print_string_new
    call print_nl_new

.end:
    ; Set the returned value and reset main's stack frame
    ; You can indeed check the returned value with 'echo $?'
    ; Notice how if we perform a 'mov rax, -1' we'll indeed
    ; see how 'echo $?' yields '255'!
    xor rax, rax
    add rsp, 32
    pop rbp
    ret