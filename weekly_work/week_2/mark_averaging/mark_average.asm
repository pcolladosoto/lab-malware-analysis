; Mark averaging assembly program

%include "../../../libs/io_v6.asm"

global main

section .data

; Define the number of marks in the program
n_marks equ 5

; Note we are defining the marks as 64-bit quadrawords (dq) so that they
; are aligned to the register size and we avoid any nasty errors
nzero_msg: db "Number of non-zero marks -> ", 0x0
avg_msg:  db "Average -> ", 0x0
rmdr_msg: db "Remainder -> ", 0x0
marks: dq 33, 0, 100, 0, 100

section .text

main:
    ; Set up main's stack frame
    push rbp
    mov rbp, rsp
    sub rsp,32

    ; Register breakdown:
        ; RAX -> Loop counter
        ; RCX -> Number of non-zero values
        ; RDX -> Total sum of the marks

    ; Zero-out the registers we are going to use
    xor rax, rax
    xor rcx, rcx
    xor rdx, rdx

.loop:
    ; Load each element's address into RDI. Note we multiply the loop counter
    ; by 8 because each data takes up 8 bytes (64 bits) as they are quadrawords!
    ; The rel tag maked the addresses we handle relative to the RIP (PC)
    lea rdi, [rel marks + 8 * rax]
    mov rbx, [rdi]
    cmp rbx, 0
    je .lend
    inc rcx
    add rdx, rbx

.lend:
    ; Increment the counter and check if we need to break out of the loop!
    inc rax
    cmp rax, n_marks
    je .results
    jmp .loop

.results:
    ; Apparently the I/O functions won't mess with RCX, we could add a 'push rdi' on line   to be sure though...
    push rcx
    mov rdi, QWORD nzero_msg
    call print_string_new
    pop rdi
    call print_int_new
    call print_nl_new

    mov rax, rdx

    ; We need to zero out RDX as it also plays a role in the division!
    xor rdx, rdx

    ; Divided by the number on non-zero values
    div rcx

    ; The division's result is in RAX and the remainder is passed on RDX
    ; We push them in the opposite order as the stack works on a LIFO basis
    ; As the I/O functions don't mess with RDX either we could avoid pushing
    ; it too but it won't hurt us either...
    push rdx
    push rax

    ; Just print the data
    mov rdi, QWORD avg_msg
    call print_string_new
    pop rdi
    call print_int_new
    call print_nl_new

    mov rdi, QWORD rmdr_msg
    call print_string_new
    pop rdi
    call print_int_new
    call print_nl_new

    ; Reset main's stack frame
    add rsp, 32
    pop rbp

    ret