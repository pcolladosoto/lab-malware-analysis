; Test programme for IO stuff

%include "../../libs/io_v6.asm"

global main
section .data

echo_request: db "Please enter a number: ",0
echo_number:  db "The number you entered was:",0
echo_bye: db "Goodbye!",0

section .text

main:
    ; We have these three lines for compatability reasons
    push rbp
    mov rbp, rsp
    sub rsp,32

    ; Load up the message to ask for a number
    mov rdi, QWORD echo_request
    call print_string_new

    ; Read an int into rax
    ; We'll push it on the stack. More on that in a second.
    call read_int_new
    push rax

    ; Print out the message
    mov rdi, QWORD echo_number
    call print_string_new
    call print_nl_new

    ; Pop the int into rdi so that 'print_int_new' can print it
    pop rdi

    ; We could think that just copying rax's value into rdi would do the
    ; trick and that way we could avoid 2 memory accesses as well as 1 instruction.
    ; The thing is we can't count on functions leaving the registers as they found
    ; them as some of them are quite "greedy". In this scenario and through some
    ; debugging we can see how calling 'print_string_new' sets rax to 0, in fact
    ; destroying our data. That's why we push rax onto the stack as soon as we read
    ; the int because we can't be sure somebody is going to mess it up before we get
    ; to printing the result... We do know funcitons will leave the stack unchanged
    ; so we can alwars rely on it to pass data around.
    ;
    ; What's more, if we take a look at line 64 in '../../libs/io_v6.asm' we can see how
    ; rax is used to pass a return code to the caller. In that line rax is XORed with itself
    ; effectively setting it to 0. That's why we can't rely on it to store the integer
    ; given by the user...
    ; mov rdi, rax

    call print_int_new
    call print_nl_new

    ; Print the goodby message
    mov rdi, QWORD echo_bye
    call print_string_new
    call print_nl_new

    ; Restoring the initial state (compatibility stuff)
    add rsp, 32
    pop rbp

    ret