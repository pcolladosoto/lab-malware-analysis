; Management System

%ifdef DCKR
    ; Docker includes
    %include "../libs/io_v6.asm"
    %include "user_stuff.asm"
    %include "comp_stuff.asm"
%else
    ; SASM includes
    %include "/home/malware/mw_repo/libs/io_v6.asm"
    %include "/home/malware/mw_repo/management_system/user_stuff.asm"
    %include "/home/malware/mw_repo/management_system/comp_stuff.asm"
%endif

global main

section .data

; Note that by inspecting any ASCII table we see how:
    ; + ---------------------------------------------------- +
    ; | Special Character     --   Dec Value   --  Hex Value |
    ; | Horizontal Tab (HT)   --      9        --    0x9     |
    ; | Newline/Linefeed (LF) --      10       --    0xA     |
    ; |        NULL           --      0        --    0x0     |

menu_str:
    db "Menu:", 0xA, \
        0x9, " 1. Add user", 0xA, \
        0x9, " 2. Delete user", 0xA, \
        0x9, " 3. Search for user", 0xA, \
        0x9, " 4. List all users", 0xA, \
        0x9, " 5. Count users", 0xA, \
        0x9, " 6. Add computer", 0xA, \
        0x9, " 7. Delete computer", 0xA, \
        0x9, " 8. Search for computer", 0xA, \
        0x9, " 9. List all computers", 0xA, \
        0x9, "10. Count computers", 0xA, \
        0x9, "11. Exit", 0xA, \
        "Please enter an option --> ", 0x0

reply:
    db "Given option --> ", 0x0

section .text

main:
    ; We have these three lines for compatability reasons
    push rbp
    mov rbp, rsp
    sub rsp, 32

.menu:
    ; Load up the message to ask for a number
    mov rdi, QWORD menu_str
    call print_string_new

    ; Read the option
    call read_int_new
    ; push rax

    ; Echo the option back to the user
    ; mov rdi, QWORD reply
    ; call print_string_new
    ; pop rdi
    ; call print_int_new
    ; call print_nl_new

    cmp rax, 1
        je .add_usr
    cmp rax, 2
        je .del_usr ; If we jump we aren't pushing EIP into the stack and ret throws us into nowhere!
    cmp rax, 3
        je .find_usr
    cmp rax, 4
        je .ls_usrs
    cmp rax, 5
        je .cnt_usrs
    cmp rax, 6
        je .add_comp
    cmp rax, 7
        je .del_comp
    cmp rax, 8
        je .find_comp
    cmp rax, 9
        je .ls_comps
    cmp rax, 10
        je .cnt_comps
    cmp rax, 11
        je .end

    call clear_screen
    jmp .menu

.end:
    ; call clear_screen
    ; Restoring the initial state (compatibility stuff)
    add rsp, 32
    pop rbp

    xor rax, rax

    ret

.add_usr:
    call add_user
    jmp .clear_screen

.del_usr:
    call del_user
    jmp .clear_screen

.find_usr:
    call find_user
    jmp .clear_screen

.ls_usrs:
    call print_users
    jmp .clear_screen

.cnt_usrs:
    call count_users
    jmp .clear_screen

.add_comp:
    call add_comp
    jmp .clear_screen

.del_comp:
    call del_comp
    jmp .clear_screen

.find_comp:
    ; call find_comp
    jmp .clear_screen

.ls_comps:
    call print_comps
    jmp .clear_screen

.cnt_comps:
    call count_comps
    jmp .clear_screen

.clear_screen:
    call read_int_new
    call clear_screen
    jmp .menu