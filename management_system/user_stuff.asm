; Subroutines regarding the management of users
%include "../libs/io_v6.asm"
; %include "/home/malware/mw_repo/libs/io_v6.asm"
; User data
    ; Surename -> A string of at most 64 chars
    ; First Name -> A string of at most 64 chars
    ; Dep -> Any of:
                ; Development
                ; IT Support
                ; Finance
                ; HR
        ; The largest string is "Development" which is 11 chars long!
    ; User ID -> In the form of pXXXXXXX, where XXXXXXX is a 7 digit number
    ; Email -> With the userID@helpdesk.co.uk ending

    ; The above suggests we need to reserve: (64 + 1) * 2 + (11 + 1) + (8 + 1) + (23 + 1) = 175 Bytes per user
    ; We then need to reserve 175 * 100 = 1750 bytes to fit all the user data

section .data

MAX_USERS equ 100
B_PER_USER equ 175
NAME_SIZE equ 65
DEP_SIZE equ 12
UID_SIZE equ 9
EMAIL_SIZE equ 24

curr_users:
    dq 0x0

; Targets to check against
v_dep_a: db "Development", 0x0
v_dep_b: db "IT Support", 0x0
v_dep_c: db "Finance", 0x0
v_dep_d: db "HR", 0x0

; General data
email_end:
    db "@helpdesk.co.uk", 0x0

; Output messages
users_full_msg:
    db "We already have 100 users...", 0xA, 0x0

surename_msg:
    db "Please enter a surename -> ", 0x0

firstname_msg:
    db "Please enter a first name -> ", 0x0

dep_msg:
    db "Please enter a department -> ", 0x0

dep_err_msg:
    db "This department name is NOT supported... Input a new one!", 0xA, 0x0

uid_msg:
    db "Please enter a User ID -> ", 0x0

uid_err_msg_c:
    db "Invalid User ID... Input a new one!", 0xA, 0x0

uid_err_msg_a:
    db "Invalid initial letter!", 0xA, 0x0

uid_err_msg_b:
    db "The User ID is NOT 8 characters long... Input a new one!", 0xA, 0x0

email_msg:
    db "Please enter an email -> ", 0x0

section .bss

user_data:
    resb MAX_USERS * B_PER_USER

section .text

add_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    push rdi

    ; mov rdi, QWORD foo
    ; call print_string_new

    mov rax, [curr_users]
    cmp rax, MAX_USERS
    je .full

    ; Apparently we can only multiply registers by powers of 2 when computing effective addresses...
    imul rax, B_PER_USER
    lea rbx, [user_data + rax]
    ; Note none of the functions we are about to call fiddle with RBX. Our address is safe!

    ; Get the surename
    mov rdi, QWORD surename_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes by forcing a NULL character
    ; in the reading buffer defined in the I/O library file
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; Get the first name
    lea rbx, [rbx + NAME_SIZE]
    mov rdi, QWORD firstname_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes!
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; Get the department
    lea rbx, [rbx + NAME_SIZE]
.get_dep:
    mov rdi, QWORD dep_msg
    call print_string_new
    call read_string_new

    ; We can maybe use test instead of cmp!
    mov rcx, rax
    mov rdi, rcx
    mov rsi, v_dep_a
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_b
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_c
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_d
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rdi, QWORD dep_err_msg
    call print_string_new
    jmp .get_dep

.copy_dep:
    ; Copy the department as we know it's correct!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string

    lea rbx, [rbx + DEP_SIZE]
.get_id:
    mov rdi, QWORD uid_msg
    call print_string_new
    call read_string_new
    ; lea rcx, [rax + UID_SIZE - 1]
    ; mov BYTE [rcx], 0x0

    ; Validate the ID
    mov rcx, rax
    mov al, BYTE [rcx]
    ; 'p' == 0x70
    cmp al, 0x70
    jne .id_err_a

    lea rdi, [rcx + 0x1]
    ; Don't take the 'p' into account!
    call atoi

    ; Check if the 7 last digits are indeed a number!
    cmp rax, 0xFFFFFFFFFFFFFFFF
    je .id_err_c
    mov rsi, rcx
    call string_len
    cmp rax, 0x8
    jne .id_err_b

    ; Copy the UID and move on!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string
    jmp .build_email

.id_err_a:
    mov rdi, QWORD uid_err_msg_a
    call print_string_new
    jmp .get_id

.id_err_b:
    mov rdi, QWORD uid_err_msg_b
    call print_string_new
    jmp .get_id

.id_err_c:
    mov rdi, QWORD uid_err_msg_c
    call print_string_new
    jmp .get_id

.build_email:
    ; Copy the username
    mov rsi, rbx
    lea rbx, [rbx + UID_SIZE]
    mov rdi, rbx
    call copy_string

    mov rsi, email_end
    lea rdi, [rdi + UID_SIZE - 1]
    call copy_string

    ; Update the number of users
    mov rax, [curr_users]
    inc rax
    mov QWORD [curr_users], rax

    jmp .end

.full:
    mov rdi, QWORD users_full_msg
    call print_string_new

.end:
    pop rdi
    add rsp, 32
    pop rbp

    ret

del_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    push rdi

    ; mov rdi, QWORD fii
    ; call print_string_new

    pop rdi
    add rsp, 32
    pop rbp

    ret
