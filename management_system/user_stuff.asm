; Subroutines regarding the management of users

%ifdef DCKR
    ; Docker includes
    %include "../libs/io_v6.asm"
    %include "output_msgs.asm"
    %include "misc_subroutines.asm"
%else
    ; SASM Includes
    %include "/home/malware/mw_repo/libs/io_v6.asm"
    %include "/home/malware/mw_repo/management_system/output_msgs.asm"
    %include "/home/malware/mw_repo/management_system/misc_subroutines.asm"
%endif

; User data
    ; Surename -> A string of at most 64 chars
    ; First Name -> A string of at most 64 chars
    ; Dep -> Any of:
                ; Development
                ; IT Support
                ; Finance
                ; HR
        ; The largest string is "Development" which is 11 chars long!
    ; User ID -> In the form of pXXXXXXX, where XXXXXXX is a 7 digit number
    ; Email -> With the userID@helpdesk.co.uk ending

    ; The above suggests we need to reserve: 1 + (64 + 1) * 2 + (11 + 1) + (8 + 1) + (23 + 1) = 176 Bytes per user
    ; We then need to reserve 176 * 100 = 17600 bytes to fit all the user data
    ; Note the first byte marks whether a user recor is valid or not!

section .data

; Constants regarding the sizes of the elements conforming a user data record

; Maximum number of users
MAX_USERS equ 100

; Lenght in Bytes of each user record
B_PER_USER equ 175

; Size of both name fields in the record
NAME_SIZE equ 65

; Size of the department field in the record
DEP_SIZE equ 12

; Size of the user ID in the record
UID_SIZE equ 9

; Size of the e-mail in the reocord
EMAIL_SIZE equ 24

; This Quadraword contains the current number of registered users
curr_users:
    dq 0x0

; Target strings to check department validity against
v_dep_a: db "Development", 0x0
v_dep_b: db "IT Support", 0x0
v_dep_c: db "Finance", 0x0
v_dep_d: db "HR", 0x0

; General user data
email_end:
    db "@helpdesk.co.uk", 0x0

; This area contains all the record data. It's all initialized to 0 thanks to NASM's times keyword which will
    ; repeat the statement it precedes X number of times. In this case, we'll initialize a byte to 0x0
    ; MAX_USERS * B_PER_USER times which is the total number of bytes we need for our records. This keyword was
    ; found on section 3.2.5 of the NASM documentation
user_data:
    times MAX_USERS * B_PER_USER db 0x0

section .text

add_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    push rdi

    mov rax, [curr_users]
    cmp rax, MAX_USERS
    je .full

    ; Apparently we can only multiply registers by powers of 2 when computing effective addresses...
    imul rax, B_PER_USER
    lea rbx, [user_data + rax]
    ; Note none of the functions we are about to call fiddle with RBX. Our address is safe!

    ; Get the surename
    mov rdi, QWORD surename_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes by forcing a NULL character
    ; in the reading buffer defined in the I/O library file
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; Get the first name
    lea rbx, [rbx + NAME_SIZE]
    mov rdi, QWORD firstname_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes!
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; Get the department
    lea rbx, [rbx + NAME_SIZE]
.get_dep:
    mov rdi, QWORD dep_msg
    call print_string_new
    call read_string_new

    ; We can maybe use test instead of cmp!
    mov rcx, rax
    mov rdi, rcx
    mov rsi, v_dep_a
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_b
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_c
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_d
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rdi, QWORD dep_err_msg
    call print_string_new
    jmp .get_dep

.copy_dep:
    ; Copy the department as we know it's correct!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string

    lea rbx, [rbx + DEP_SIZE]
.get_id:
    mov rdi, QWORD uid_msg
    call print_string_new
    call read_string_new

    mov rcx, rax
    mov dl, BYTE 0x70
    call validate_id
    cmp rax, 0x1
    jne .get_id

    mov rsi, rcx
    lea rdi, [user_data + 2 * NAME_SIZE + DEP_SIZE]
    mov r8, B_PER_USER
    mov r9, [curr_users]
    call find_record
    cmp rax, 0x1
    je .not_unique
    jmp .copy_id

    .not_unique:
        mov rdi, QWORD id_not_unique_msg
        call print_string_new
        jmp .get_id

    .copy_id:
        ; mov rsi, rcx
        mov rdi, rbx
        call copy_string

.build_email:
    ; Copy the username
    mov rsi, rbx
    lea rbx, [rbx + UID_SIZE]
    mov rdi, rbx
    call copy_string

    mov rsi, email_end
    lea rdi, [rdi + UID_SIZE - 1]
    call copy_string

    ; Update the number of users
    mov rax, [curr_users]
    inc rax
    mov QWORD [curr_users], rax

    jmp .end

.full:
    mov rdi, QWORD users_full_msg
    call print_string_new

.end:
    pop rdi
    add rsp, 32
    pop rbp

    ret

del_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rax
    push rbx
    push rdi

    ; Just delete a user by invalidating the first byte in the Department name
    mov rax, [curr_users]
    cmp rax, 0x0
    je .err
    dec rax
    mov QWORD [curr_users], rax
    imul rax, B_PER_USER
    lea rbx, [user_data + rax + NAME_SIZE]
    lea rax, [user_data + rax + 2 * NAME_SIZE]
    mov BYTE [rax], 0x0
    mov rdi, QWORD del_msg
    call print_string_new
    mov rdi, rbx
    call print_string_new
    call print_nl_new
    jmp .end

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new

.end:
    pop rdi
    pop rbx
    pop rax

    add rsp, 32
    pop rbp

    ret

print_users:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_users]
    cmp rdx, 0x0
    je .err
    xor rbx, rbx

    lea rcx, [user_data]
.loop:
    cmp rdx, rbx
    je .loope
    ; mov rcx, rbx
    ; imul rcx, B_PER_USER
    ; lea rcx, [user_data + rcx]
    mov rdi, QWORD print_new_user_msg
    call print_string_new
    mov rdi, rbx
    call print_int_new
    call print_nl_new

    mov rdi, rcx
    call print_user
    lea rcx, [rcx + B_PER_USER]

    inc rbx
    jmp .loop

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new

.loope:
    ; Remember to pop what you pushed!
    pop rdi
    pop rcx
    pop rbx
    pop rdx

    add rsp, 32
    pop rbp

    ret

; The address of the user to print is passed on RDI!
print_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rsi
    push rdi

    mov rsi, rdi

    mov rdi, QWORD print_surename_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + NAME_SIZE]
    mov rdi, QWORD print_name_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + NAME_SIZE]
    mov rdi, QWORD print_dep_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + DEP_SIZE]
    mov rdi, QWORD print_uid_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + UID_SIZE]
    mov rdi, QWORD print_email_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    pop rdi
    pop rsi

    add rsp, 32
    pop rbp

    ret

count_users:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi

    mov rdi, QWORD n_users_msg_a
    call print_string_new
    mov rdi, [curr_users]
    call print_int_new
    mov rdi, QWORD n_users_msg_b
    call print_string_new

    pop rdi

    add rsp, 32
    pop rbp

    ret

find_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rsi
    push rax
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_users]
    cmp rdx, 0x0
    je .err

.get_target:
    ; Get the first name to look for
    mov rdi, QWORD user_lookup_msg
    call print_string_new
    call read_string_new

    mov rcx, rax
    mov dl, BYTE 0x70
    call validate_id
    cmp rax, 0x1
    jne .get_target

    mov rsi, rcx
    lea rdi, [user_data + 2 * NAME_SIZE + DEP_SIZE]
    mov r8, B_PER_USER
    mov r9, rdx
    call find_record

    cmp rax, 0x1
    jne .not_found

.found:
    ; Get rid of the offset we introduced
    lea rdi, [rdi - (2 * NAME_SIZE + DEP_SIZE)]
    call print_user
    jmp .end

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new
    jmp .end

.not_found:
    mov rdi, QWORD user_not_found_msg
    call print_string_new

.end:
    ; Remember to pop what you pushed!
    pop rdi
    pop rcx
    pop rbx
    pop rdx
    pop rax
    pop rsi

    add rsp, 32
    pop rbp

    ret