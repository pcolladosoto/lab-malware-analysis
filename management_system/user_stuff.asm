; Subroutines regarding the management of users

%ifdef DCKR
    ; Docker includes
    %include "../libs/io_v6.asm"
    %include "output_msgs.asm"
    %include "misc_subroutines.asm"
%else
    ; SASM Includes
    %include "/home/malware/mw_repo/libs/io_v6.asm"
    %include "/home/malware/mw_repo/management_system/output_msgs.asm"
    %include "/home/malware/mw_repo/management_system/misc_subroutines.asm"
%endif

; User data structure
    ; Surename -> A string of at most 64 chars
    ; First Name -> A string of at most 64 chars
    ; Dep -> Any of:
                ; Development
                ; IT Support
                ; Finance
                ; HR
        ; The largest string is "Development" which is 11 chars long!
    ; User ID -> In the form of pXXXXXXX, where XXXXXXX is a 7 digit number
    ; Email -> With the userID@helpdesk.co.uk ending

    ; The above suggests we need to reserve: 1 + (64 + 1) * 2 + (11 + 1) + (8 + 1) + (23 + 1) = 176 Bytes per user
    ; We then need to reserve 176 * 100 = 17600 bytes to fit all the user data
    ; Note the first byte marks whether a user recor is valid or not!

; Data needed for validating and storing user data
section .data

; Constants regarding the sizes of the elements conforming a user data record

; Maximum number of users
MAX_USERS equ 100

; Lenght in Bytes of each user record
B_PER_USER equ 175

; Size of both name fields in the record
NAME_SIZE equ 65

; Size of the department field in the record
DEP_SIZE equ 12

; Size of the user ID in the record
UID_SIZE equ 9

; Size of the e-mail in the reocord
EMAIL_SIZE equ 24

; This Quadraword contains the current number of registered users
curr_users:
    dq 0x0

; Target strings to check department validity against
v_dep_a: db "Development", 0x0
v_dep_b: db "IT Support", 0x0
v_dep_c: db "Finance", 0x0
v_dep_d: db "HR", 0x0

; General user data
email_end:
    db "@helpdesk.co.uk", 0x0

; This area contains all the record data. It's all initialized to 0 thanks to NASM's times keyword which will
    ; repeat the statement it precedes X number of times. In this case, we'll initialize a byte to 0x0
    ; MAX_USERS * B_PER_USER times which is the total number of bytes we need for our records. This keyword was
    ; found on section 3.2.5 of the NASM documentation
user_data:
    times MAX_USERS * B_PER_USER db 0x0

; User data handling functions
section .text

add_user:
    ; Input paramters:
        ; NONE

    ; Return value:
        ; NONE

    ; Create a new stack frame
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Save the callers stack context
    push rdi

    ; Load the current number of users onto RAX
    mov rax, [curr_users]
    ; Check if we have reached the user limit
    cmp rax, MAX_USERS
    ; If we have, just quit printing an error message. Otherwise we'll continue
        ; in the subroutine
    je .full

    ; Apparently we can only multiply registers by powers of 2 when computing effective addresses
        ; so we'll multiply the current number of users, currently in RAX, by the size of a
        ; user record and then add that offset to the initial address, loading that into RBX.
        ; RBX will always contain the address of the next piece of data to fill!
        ; Note none of the functions we are about to call fiddle with RBX. Our address is safe!
    imul rax, B_PER_USER
    lea rbx, [user_data + rax]

    ; ************
    ; * Surename *
    ; ************

    ; Output a message asking for the surename
    mov rdi, QWORD surename_msg
    call print_string_new
    ; Read the string. A pointer to it is returned in RAX
    call read_string_new
    ; Chop the string down to 65 Bytes by forcing a NULL character
        ; in the reading buffer defined in the I/O library file
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0

    ; After forcibly chopping the string copy it to the
        ; data record
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; **************
    ; * First Name *
    ; **************

    ; Make RBX point to the next string we have to fill out
    lea rbx, [rbx + NAME_SIZE]

    ; Output a message asking for the first name
    mov rdi, QWORD firstname_msg
    call print_string_new
    ; Read that into the I/O buffer. The pointer to the read string
        ; will be on RAX
    call read_string_new
    ; Chop the string down to 65 Bytes by forcing a NULL character
        ; in the reading buffer defined in the I/O library file
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0

    ; Just copy the string to the user record
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; **************
    ; * Department *
    ; **************

    ; Make RBX point to the next string we have to fill out
    lea rbx, [rbx + NAME_SIZE]
    .get_dep:
        ; Output a message asking for the department
        mov rdi, QWORD dep_msg
        call print_string_new
        call read_string_new

        ; As we are going to call strings_are_equal we need to save the pointer
            ; to the read string into RCX to save it! We'll then make RSI point
            ; to the targets we defined in the .data section to check if any
            ; of them check out. If they do we'll copy the string to the record
            ; area.
        mov rcx, rax
        mov rdi, rcx
        mov rsi, v_dep_a
        call strings_are_equal
        cmp rax, 0x1
        je .copy_dep
        mov rsi, v_dep_b
        call strings_are_equal
        cmp rax, 0x1
        je .copy_dep
        mov rsi, v_dep_c
        call strings_are_equal
        cmp rax, 0x1
        je .copy_dep
        mov rsi, v_dep_d
        call strings_are_equal
        cmp rax, 0x1
        je .copy_dep
        ; If none of the targets were found we'll fall through here, printing an error
            ; message and asking for the department again
        mov rdi, QWORD dep_err_msg
        call print_string_new
        jmp .get_dep

    .copy_dep:
        ; Copy the department as we know it's correct!
        mov rsi, rcx
        mov rdi, rbx
        call copy_string

        ; ***********
        ; * User ID *
        ; ***********

        ; Make RBX point to the next string we have to fill out
        lea rbx, [rbx + DEP_SIZE]
    .get_id:
        ; Output a message asking for the department
        mov rdi, QWORD uid_msg
        call print_string_new
        call read_string_new

        ; Prepare to call validate_id
            ; RCX -> Pointer to the read ID
            ; DL -> The first char we need in the ID
        mov rcx, rax
        mov dl, BYTE 0x70
        call validate_id
        ; If the ID is indeed valid fall through. Otherwise
            ; ask for the ID again
        cmp rax, 0x1
        jne .get_id

        ; Check if the ID is already being used
            ; Get ready to call find_record
                ; RSI -> ID to be added
                ; RDI -> Initial record to llok for
                ; R8 -> Size of a data record
                ; R9 -> Number of records to analyze
        mov rsi, rcx
        lea rdi, [user_data + 2 * NAME_SIZE + DEP_SIZE]
        mov r8, B_PER_USER
        mov r9, [curr_users]
        call find_record
        ; If we found the record print an error message and ask for the ID
            ; again...
        cmp rax, 0x1
        je .not_unique
        ; Otherwise just copy it and move on
        jmp .copy_id

        .not_unique:
            ; Print the error message
            mov rdi, QWORD id_not_unique_msg
            call print_string_new
            ; And ask for the ID once more
            jmp .get_id

        .copy_id:
            ; RSI is still pointing to the read ID!
            mov rdi, rbx
            call copy_string

    ; **********
    ; * E-mail *
    ; **********

    .build_email:
        ; Make RSI to the User ID we have just read
        mov rsi, rbx
        ; Make RBX point to the e-mail record area
        lea rbx, [rbx + UID_SIZE]
        mov rdi, rbx
        ; Copy the user ID into the email area
        call copy_string

        ; Copy the e-mail termination into the record area
        mov rsi, email_end
        lea rdi, [rdi + UID_SIZE - 1]
        call copy_string

        ; Update the number of users by incrementing *curr_users
        mov rax, [curr_users]
        inc rax
        mov QWORD [curr_users], rax

        ; Exit the function
        jmp .end

    .full:
        ; If we have already reached the limit of registered users print an error
            ; and exit
        mov rdi, QWORD users_full_msg
        call print_string_new

    .end:
        ; Reset the caller's context, reste the stack frame and exit
        pop rdi
        add rsp, 32
        pop rbp

        ret

del_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rax
    push rbx
    push rdi

    ; Just delete a user by invalidating the first byte in the Department name
    mov rax, [curr_users]
    cmp rax, 0x0
    je .err
    dec rax
    mov QWORD [curr_users], rax
    imul rax, B_PER_USER
    lea rbx, [user_data + rax + NAME_SIZE]
    lea rax, [user_data + rax + 2 * NAME_SIZE]
    mov BYTE [rax], 0x0
    mov rdi, QWORD del_msg
    call print_string_new
    mov rdi, rbx
    call print_string_new
    call print_nl_new
    jmp .end

    .err:
        mov rdi, QWORD no_users_msg
        call print_string_new

    .end:
        pop rdi
        pop rbx
        pop rax

        add rsp, 32
        pop rbp

        ret

print_users:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_users]
    cmp rdx, 0x0
    je .err
    xor rbx, rbx

    lea rcx, [user_data]
    .loop:
        cmp rdx, rbx
        je .loope
        ; mov rcx, rbx
        ; imul rcx, B_PER_USER
        ; lea rcx, [user_data + rcx]
        mov rdi, QWORD print_new_user_msg
        call print_string_new
        mov rdi, rbx
        call print_int_new
        call print_nl_new

        mov rdi, rcx
        call print_user
        lea rcx, [rcx + B_PER_USER]

        inc rbx
        jmp .loop

    .err:
        mov rdi, QWORD no_users_msg
        call print_string_new

    .loope:
        ; Remember to pop what you pushed!
        pop rdi
        pop rcx
        pop rbx
        pop rdx

        add rsp, 32
        pop rbp

        ret

; The address of the user to print is passed on RDI!
print_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rsi
    push rdi

    mov rsi, rdi

    mov rdi, QWORD print_surename_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + NAME_SIZE]
    mov rdi, QWORD print_name_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + NAME_SIZE]
    mov rdi, QWORD print_dep_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + DEP_SIZE]
    mov rdi, QWORD print_uid_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + UID_SIZE]
    mov rdi, QWORD print_email_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    pop rdi
    pop rsi

    add rsp, 32
    pop rbp

    ret

count_users:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi

    mov rdi, QWORD n_users_msg_a
    call print_string_new
    mov rdi, [curr_users]
    call print_int_new
    mov rdi, QWORD n_users_msg_b
    call print_string_new

    pop rdi

    add rsp, 32
    pop rbp

    ret

find_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rsi
    push rax
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_users]
    cmp rdx, 0x0
    je .err

    .get_target:
        ; Get the first name to look for
        mov rdi, QWORD user_lookup_msg
        call print_string_new
        call read_string_new

        mov rcx, rax
        mov dl, BYTE 0x70
        call validate_id
        cmp rax, 0x1
        jne .get_target

        mov rsi, rcx
        lea rdi, [user_data + 2 * NAME_SIZE + DEP_SIZE]
        mov r8, B_PER_USER
        mov r9, rdx
        call find_record

        cmp rax, 0x1
        jne .not_found

    .found:
        ; Get rid of the offset we introduced
        lea rdi, [rdi - (2 * NAME_SIZE + DEP_SIZE)]
        call print_user
        jmp .end

    .err:
        mov rdi, QWORD no_users_msg
        call print_string_new
        jmp .end

    .not_found:
        mov rdi, QWORD user_not_found_msg
        call print_string_new

    .end:
        ; Remember to pop what you pushed!
        pop rdi
        pop rcx
        pop rbx
        pop rdx
        pop rax
        pop rsi

        add rsp, 32
        pop rbp

        ret