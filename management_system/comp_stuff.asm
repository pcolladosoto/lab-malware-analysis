; Subroutines regarding the management of computers

%ifdef DCKR
    ; Docker includes
    %include "../libs/io_v6.asm"
    %include "output_msgs.asm"
    %include "misc_subroutines.asm"
%else
    ; SASM includes
    %include "/home/malware/mw_repo/libs/io_v6.asm"
    %include "/home/malware/mw_repo/management_system/output_msgs.asm"
    %include "/home/malware/mw_repo/management_system/misc_subroutines.asm"
%endif

; Comp data
    ; Comp Name -> In the form of cXXXXXXX, where XXXXXXX is a 7 digit number
    ; IP Address -> In the form XXX.XXX.XXX.XXX where X is a digit
    ; OS -> Any of:
                ; Linux
                ; Windows
                ; Mac OSX
        ; The largest string is 7 chars long!
    ; User ID of the user -> In the form of pXXXXXXX, where XXXXXXX is a 7 digit number
    ; Date of purchase -> In the dd/mm/yyyy format where, d, m and y are digits!

    ; The above suggests we need to reserve: 1 + (8 + 1) + (15 + 1) + (7 + 1) + (8 + 1) + (10 + 1) = 53 Bytes per computer
    ; We then need to reserve 53 * 500 = 26500 bytes to fit all the user data
    ; Note the first byte marks whether a user recor is valid or not!

section .data

MAX_COMPS equ 500
B_PER_COMP equ 53
CID_SIZE equ 9
IP_SIZE equ 16
OS_SIZE equ 8
UID_SIZE equ 9
DATE_SIZE equ 11

curr_comps:
    dq 0x0

; Targets to check against
v_os_a: db "Linux", 0x0
v_os_b: db "Windows", 0x0
v_os_c: db "Mac OSX", 0x0

comp_data:
    times MAX_COMPS * B_PER_COMP db 0x0

section .text

add_comp:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    push rdi

    mov rax, [curr_comps]
    cmp rax, MAX_COMPS
    je .full

    ; Apparently we can only multiply registers by powers of 2 when computing effective addresses...
    imul rax, B_PER_COMP
    lea rbx, [comp_data + rax]
    ; Note none of the functions we are about to call fiddle with RBX. Our address is safe!

.get_cid:
    mov rdi, QWORD cid_msg
    call print_string_new
    call read_string_new

    ; Validate the ID
    mov rcx, rax
    mov dl, BYTE 0x63
    call validate_id
    cmp rax, 0x1
    jne .get_cid

    ; Copy the CID and move on!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string
    jmp .get_ip_init

.get_ip_init:
    lea rbx, [rbx + CID_SIZE]
.get_ip:
    mov rdi, QWORD ip_msg
    call print_string_new
    call read_string_new

    mov rdi, rax
    call validate_ip
    cmp rax, 0x0
    je .ip_err

    mov rsi, rdi
    mov rdi, rbx
    call copy_string
    jmp .get_os_init

.ip_err:
    mov rdi, QWORD ip_err_msg
    call print_string_new
    jmp .get_ip

.get_os_init:
    lea rbx, [rbx + IP_SIZE]
.get_os:
    mov rdi, QWORD os_msg
    call print_string_new
    call read_string_new

    ; We can maybe use test instead of cmp!
    mov rcx, rax
    mov rdi, rcx
    mov rsi, v_os_a
    call strings_are_equal
    cmp rax, 0x1
    je .copy_os
    mov rsi, v_os_b
    call strings_are_equal
    cmp rax, 0x1
    je .copy_os
    mov rsi, v_os_c
    call strings_are_equal
    cmp rax, 0x1
    je .copy_os
    mov rdi, QWORD os_err_msg
    call print_string_new
    jmp .get_os

.copy_os:
    ; Copy the OS as we know it's correct!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string

    lea rbx, [rbx + OS_SIZE]
.get_uid:
    mov rdi, QWORD cuid_msg
    call print_string_new
    call read_string_new

    mov rcx, rax
    mov dl, BYTE 0x70
    call validate_id
    cmp rax, 0x1
    jne .get_uid

    mov rsi, rcx
    mov rdi, rbx
    call copy_string
    jmp .get_date_init

.get_date_init:
    lea rbx, [rbx + UID_SIZE]
.get_date:
    mov rdi, QWORD date_msg
    call print_string_new
    call read_string_new

    mov rdi, rax
    call validate_date
    cmp rax, 0x1
    jne .get_date

    mov rsi, rdi
    mov rdi, rbx
    call copy_string

    ; Update the number of computers
    mov rax, [curr_comps]
    inc rax
    mov QWORD [curr_comps], rax

    jmp .end

.full:
    mov rdi, QWORD comps_full_msg
    call print_string_new

.end:
    pop rdi
    add rsp, 32
    pop rbp

    ret

del_comp:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rax
    push rbx
    push rdi

    ; Just delete a user by invalidating the first byte in the Department name
    mov rax, [curr_comps]
    cmp rax, 0x0
    je .err
    dec rax
    mov QWORD [curr_comps], rax
    imul rax, B_PER_COMP
    lea rbx, [comp_data + rax]
    mov rdi, QWORD del_msg
    call print_string_new
    mov rdi, rbx
    call print_string_new
    call print_nl_new
    jmp .end

.err:
    mov rdi, QWORD no_comps_msg
    call print_string_new

.end:
    pop rdi
    pop rbx
    pop rax

    add rsp, 32
    pop rbp

    ret

print_comps:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_comps]
    cmp rdx, 0x0
    je .err
    xor rbx, rbx

    lea rcx, [comp_data]
.loop:
    cmp rdx, rbx
    je .loope
    mov rdi, QWORD print_new_comp_msg
    call print_string_new
    mov rdi, rbx
    call print_int_new
    call print_nl_new

    mov rdi, rcx
    call print_comp
    lea rcx, [rcx + B_PER_COMP]

    inc rbx
    jmp .loop

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new

.loope:
    ; Remember to pop what you pushed!
    pop rdi
    pop rcx
    pop rbx
    pop rdx

    add rsp, 32
    pop rbp

    ret

; The address of the user to print is passed on RDI!
print_comp:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rsi
    push rdi

    mov rsi, rdi

    mov rdi, QWORD print_cid_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + CID_SIZE]
    mov rdi, QWORD print_ip_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + IP_SIZE]
    mov rdi, QWORD print_os_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + OS_SIZE]
    mov rdi, QWORD print_uid_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + UID_SIZE]
    mov rdi, QWORD print_date_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    pop rdi
    pop rsi

    add rsp, 32
    pop rbp

    ret

count_comps:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi

    mov rdi, QWORD n_comps_msg_a
    call print_string_new
    mov rdi, [curr_comps]
    call print_int_new
    mov rdi, QWORD n_comps_msg_b
    call print_string_new

    pop rdi

    add rsp, 32
    pop rbp

    ret

; find_comp:
;     push rbp
;     mov rbp, rsp
;     sub rsp, 32

;     ; Remember to push what you use!
;     push rsi
;     push rax
;     push rdx
;     push rbx
;     push rcx
;     push rdi

;     mov rdx, [curr_users]
;     cmp rdx, 0x0
;     je .err

;     ; Get the first name to look for
;     mov rdi, QWORD comp_lookup_msg
;     call print_string_new
;     call read_string_new
;     ; Chop the string down to 65 Bytes!
;     lea rcx, [rax + NAME_SIZE - 1]
;     mov BYTE [rcx], 0x0
;     mov rsi, rax

;     xor rbx, rbx

;     lea rdi, [user_data + NAME_SIZE]
; .loop:
;     cmp rdx, rbx
;     je .loope

;     call strings_are_equal
;     cmp rax, 0x1
;     je .found

;     lea rdi, [rdi + B_PER_USER]

;     inc rbx
;     jmp .loop

; .found:
;     ; Get rid of the offset we introduced
;     lea rdi, [rdi - NAME_SIZE]
;     call print_user
;     jmp .end

; .err:
;     mov rdi, QWORD no_users_msg
;     call print_string_new
;     jmp .end

; .loope:
;     mov rdi, QWORD user_not_found_msg
;     call print_string_new

; .end:
;     ; Remember to pop what you pushed!
;     pop rdi
;     pop rcx
;     pop rbx
;     pop rdx
;     pop rax
;     pop rsi

;     add rsp, 32
;     pop rbp

;     ret