; Subroutines regarding the management of computers

%include "../libs/io_v6.asm"
%include "output_msgs.asm"
; %include "/home/malware/mw_repo/libs/io_v6.asm"

; Comp data
    ; Comp Name -> In the form of cXXXXXXX, where XXXXXXX is a 7 digit number
    ; IP Address -> In the form XXX.XXX.XXX.XXX where X is a digit
    ; OS -> Any of:
                ; Linux
                ; Windows
                ; Mac OSX
        ; The largest string is 7 chars long!
    ; User ID of the user -> In the form of pXXXXXXX, where XXXXXXX is a 7 digit number
    ; Date of purchase -> In the dd/mm/yyyy format where, d, m and y are digits!

    ; The above suggests we need to reserve: 1 + (8 + 1) + (15 + 1) + (7 + 1) + (8 + 1) + (10 + 1) = 53 Bytes per computer
    ; We then need to reserve 53 * 500 = 26500 bytes to fit all the user data
    ; Note the first byte marks whether a user recor is valid or not!

section .data

MAX_COMPS equ 500
B_PER_COMP equ 53
CID_SIZE equ 9
IP_SIZE equ 16
OS_SIZE equ 8
UID_SIZE equ 9
DATE_SIZE equ 11

curr_comps:
    dq 0x0

; Targets to check against
v_os_a: db "Linux", 0x0
v_os_b: db "Windows", 0x0
v_os_c: db "Mac OSX", 0x0

; Output messages
; comps_full_msg:
;     db "We already have 500 computers...", 0xA, 0x0

; cid_msg:
;     db "Please enter the Computer ID (a.k.a. computer name) -> ", 0x0

; ip_msg:
;     db "Please enter the computer's IP -> ", 0x0

; os_msg:
;     db "Please enter the computer's OS -> ", 0x0

; os_err_msg:
;     db "This OS name is NOT supported... Choose one of:", 0xA, \
;         0x9, "Linux", 0xA, 0x9, "Windows", 0xA, 0x9, "Mac OSX", 0xA, 0x0

; uid_msg:
;     db "Please enter a this computer's user's User ID -> ", 0x0

; uid_err_msg_c:
;     db "Invalid User ID... Input a new one!", 0xA, 0x0

; uid_err_msg_a:
;     db "Invalid initial letter!", 0xA, 0x0

; uid_err_msg_b:
;     db "The User ID is NOT 8 characters long... Input a new one!", 0xA, 0x0

; email_msg:
;     db "Please enter the date of purchase -> ", 0x0

; print_new_comp_msg:
;     db "Computer number: ", 0x0

; print_cid_msg:
;     db 0x9, "Computer ID", 0x9, "-> ", 0x0

; print_ip_msg:
;     db 0x9, "IP", 0x9, 0x9, "-> ", 0x0

; print_os_msg:
;     db 0x9, "OS", 0x9, "-> ", 0x0

; print_uid_msg:
;     db 0x9, "User ID", 0x9, 0x9, "-> ", 0x0

; print_date_msg:
;     db 0x9, "Date of purchase", 0x9, "-> ", 0x0

; n_comps_msg_a:
;     db "We currently have ", 0x0

; n_comps_msg_b:
;     db " registered computer(s) on the system!", 0xA, 0x0

; del_msg:
;     db "Deleted -> ", 0x0

; no_comps_msg:
;     db "There are no computers currently on the system!", 0xA, 0x0

; comp_lookup_msg:
;     db "Provide the computer ID to look for -> ", 0x0

; comp_not_found_msg:
;     db "The requested computer couldn't be found...", 0xA, 0x0

; section .bss

comp_data:
    times MAX_COMPS * B_PER_COMP db 0x0

section .text

add_comp:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    push rdi

    mov rax, [curr_comps]
    cmp rax, MAX_COMPS
    je .full

    ; Apparently we can only multiply registers by powers of 2 when computing effective addresses...
    imul rax, B_PER_COMP
    lea rbx, [comp_data + rax]
    ; Note none of the functions we are about to call fiddle with RBX. Our address is safe!

.get_id:
    mov rdi, QWORD cid_msg
    call print_string_new
    call read_string_new

    ; Validate the ID
    mov rcx, rax
    mov al, BYTE [rcx]
    ; 'c' == 0x63
    cmp al, 0x63
    jne .id_err_a

    lea rdi, [rcx + 0x1]
    ; Don't take the 'p' into account!
    call atoi

    ; Check if the 7 last digits are indeed a number!
    cmp rax, 0xFFFFFFFFFFFFFFFF
    je .id_err_c
    mov rsi, rcx
    call string_len
    cmp rax, 0x8
    jne .id_err_b

    ; Copy the CID and move on!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string
    jmp .get_os

.id_err_a:
    mov rdi, QWORD id_err_msg_a
    call print_string_new
    jmp .get_id

.id_err_b:
    mov rdi, QWORD id_err_msg_b
    call print_string_new
    jmp .get_id

.id_err_c:
    mov rdi, QWORD cid_err_msg_c
    call print_string_new
    jmp .get_id

.get_os:
    mov rdi, QWORD dep_msg
    call print_string_new
    call read_string_new

    ; We can maybe use test instead of cmp!
    mov rcx, rax
    mov rdi, rcx
    mov rsi, v_dep_a
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_b
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_c
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rsi, v_dep_d
    call strings_are_equal
    cmp rax, 0x1
    je .copy_dep
    mov rdi, QWORD dep_err_msg
    call print_string_new
    jmp .get_dep

.copy_os:
    ; Copy the department as we know it's correct!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string

    ; Get the surename
    mov rdi, QWORD cid_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes by forcing a NULL character
    ; in the reading buffer defined in the I/O library file
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; Get the first name
    lea rbx, [rbx + NAME_SIZE]
    mov rdi, QWORD firstname_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes!
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax
    mov rdi, rbx
    call copy_string

    ; Get the department
    lea rbx, [rbx + NAME_SIZE]

    lea rbx, [rbx + DEP_SIZE]
.get_id:
    mov rdi, QWORD uid_msg
    call print_string_new
    call read_string_new
    ; lea rcx, [rax + UID_SIZE - 1]
    ; mov BYTE [rcx], 0x0

    ; Validate the ID
    mov rcx, rax
    mov al, BYTE [rcx]
    ; 'p' == 0x70
    cmp al, 0x70
    jne .id_err_a

    lea rdi, [rcx + 0x1]
    ; Don't take the 'p' into account!
    call atoi

    ; Check if the 7 last digits are indeed a number!
    cmp rax, 0xFFFFFFFFFFFFFFFF
    je .id_err_c
    mov rsi, rcx
    call string_len
    cmp rax, 0x8
    jne .id_err_b

    ; Copy the UID and move on!
    mov rsi, rcx
    mov rdi, rbx
    call copy_string
    jmp .build_email

.id_err_a:
    mov rdi, QWORD uid_err_msg_a
    call print_string_new
    jmp .get_id

.id_err_b:
    mov rdi, QWORD uid_err_msg_b
    call print_string_new
    jmp .get_id

.id_err_c:
    mov rdi, QWORD uid_err_msg_c
    call print_string_new
    jmp .get_id

.build_email:
    ; Copy the username
    mov rsi, rbx
    lea rbx, [rbx + UID_SIZE]
    mov rdi, rbx
    call copy_string

    mov rsi, email_end
    lea rdi, [rdi + UID_SIZE - 1]
    call copy_string

    ; Update the number of users
    mov rax, [curr_users]
    inc rax
    mov QWORD [curr_users], rax

    jmp .end

.full:
    mov rdi, QWORD users_full_msg
    call print_string_new

.end:
    pop rdi
    add rsp, 32
    pop rbp

    ret

del_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rax
    push rbx
    push rdi

    ; Just delete a user by invalidating the first byte in the Department name
    mov rax, [curr_users]
    cmp rax, 0x0
    je .err
    dec rax
    mov QWORD [curr_users], rax
    imul rax, B_PER_USER
    lea rbx, [user_data + rax + NAME_SIZE]
    lea rax, [user_data + rax + 2 * NAME_SIZE]
    mov BYTE [rax], 0x0
    mov rdi, QWORD del_msg
    call print_string_new
    mov rdi, rbx
    call print_string_new
    call print_nl_new
    jmp .end

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new

.end:
    pop rdi
    pop rbx
    pop rax

    add rsp, 32
    pop rbp

    ret

print_users:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_users]
    cmp rdx, 0x0
    je .err
    xor rbx, rbx

    lea rcx, [user_data]
.loop:
    cmp rdx, rbx
    je .loope
    ; mov rcx, rbx
    ; imul rcx, B_PER_USER
    ; lea rcx, [user_data + rcx]
    mov rdi, QWORD print_new_user_msg
    call print_string_new
    mov rdi, rbx
    call print_int_new
    call print_nl_new

    mov rdi, rcx
    call print_user
    lea rcx, [rcx + B_PER_USER]

    ; mov rdi, QWORD print_surename_msg
    ; call print_string_new
    ; mov rdi, rcx
    ; call print_string_new
    ; call print_nl_new

    ; lea rcx, [rcx + NAME_SIZE]
    ; mov rdi, QWORD print_name_msg
    ; call print_string_new
    ; mov rdi, rcx
    ; call print_string_new
    ; call print_nl_new

    ; lea rcx, [rcx + NAME_SIZE]
    ; mov rdi, QWORD print_dep_msg
    ; call print_string_new
    ; mov rdi, rcx
    ; call print_string_new
    ; call print_nl_new

    ; lea rcx, [rcx + DEP_SIZE]
    ; mov rdi, QWORD print_uid_msg
    ; call print_string_new
    ; mov rdi, rcx
    ; call print_string_new
    ; call print_nl_new

    ; lea rcx, [rcx + UID_SIZE]
    ; mov rdi, QWORD print_email_msg
    ; call print_string_new
    ; mov rdi, rcx
    ; call print_string_new
    ; call print_nl_new

    ; lea rcx, [rcx + EMAIL_SIZE]

    inc rbx
    jmp .loop

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new

.loope:
    ; Remember to pop what you pushed!
    pop rdi
    pop rcx
    pop rbx
    pop rdx

    add rsp, 32
    pop rbp

    ret

; The address of the user to print is passed on RDI!
print_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rsi
    push rdi

    mov rsi, rdi

    mov rdi, QWORD print_surename_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + NAME_SIZE]
    mov rdi, QWORD print_name_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + NAME_SIZE]
    mov rdi, QWORD print_dep_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + DEP_SIZE]
    mov rdi, QWORD print_uid_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    lea rsi, [rsi + UID_SIZE]
    mov rdi, QWORD print_email_msg
    call print_string_new
    mov rdi, rsi
    call print_string_new
    call print_nl_new

    pop rdi
    pop rsi

    add rsp, 32
    pop rbp

    ret

count_users:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi

    mov rdi, QWORD n_users_msg_a
    call print_string_new
    mov rdi, [curr_users]
    call print_int_new
    mov rdi, QWORD n_users_msg_b
    call print_string_new

    pop rdi

    add rsp, 32
    pop rbp

    ret

find_user:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Remember to push what you use!
    push rsi
    push rax
    push rdx
    push rbx
    push rcx
    push rdi

    mov rdx, [curr_users]
    cmp rdx, 0x0
    je .err

    ; Get the first name to look for
    mov rdi, QWORD lookup_msg
    call print_string_new
    call read_string_new
    ; Chop the string down to 65 Bytes!
    lea rcx, [rax + NAME_SIZE - 1]
    mov BYTE [rcx], 0x0
    mov rsi, rax

    xor rbx, rbx

    lea rdi, [user_data + NAME_SIZE]
.loop:
    cmp rdx, rbx
    je .loope

    call strings_are_equal
    cmp rax, 0x1
    je .found

    lea rdi, [rdi + B_PER_USER]

    inc rbx
    jmp .loop

.found:
    ; Get rid of the offset we introduced
    lea rdi, [rdi - NAME_SIZE]
    call print_user
    jmp .end

.err:
    mov rdi, QWORD no_users_msg
    call print_string_new
    jmp .end

.loope:
    mov rdi, QWORD user_not_found_msg
    call print_string_new

.end:
    ; Remember to pop what you pushed!
    pop rdi
    pop rcx
    pop rbx
    pop rdx
    pop rax
    pop rsi

    add rsp, 32
    pop rbp

    ret