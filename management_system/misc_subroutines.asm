; Miscellaneous functions implementing several common functionalities

%ifdef DCKR
    %include "output_msgs.asm"
%else
    %include "/home/malware/mw_repo/management_system/output_msgs.asm"
%endif

%ifndef MISC_SUBS
    %define MISC_SUBS
section .text

validate_ip:
    ; Pointer to the current IP address comes in RDI

    ; Create a stack frame
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi
    push rcx
    push rdx
    push r11
    push r12
    push r13

    mov rcx, rdi
    mov rdx, rdi
    xor rax, rax
    xor r11, r11
    xor r12, r12
    xor r13, r13

    .loop:
        mov al, BYTE [rdx]
        ; '.' == 0x2E
        cmp al, 0x2E
        je .validate_octect
        cmp al, 0x0
        je .validate_octect_null
        inc rdx
        jmp .loop

    .validate_octect_null:
        mov r13, 0x1

    .validate_octect:
        mov BYTE [rdx], 0x0
        mov rdi, rcx
        call atoi
        cmp rax, 0xFFFFFFFFFFFFFFFF
        je .err_end
        cmp rax, 0x0
        jl .err_end
        cmp rax, 0xFF
        jg .err_end
        mov BYTE [rdx], 0x2E
        inc r11
        cmp r11, 0x4
        je .check_ok
        jg .err_end
        lea rcx, [rdx + 1]
        inc rdx
        jmp .loop

    .check_ok:
        ; We have 4 good octects!
        cmp r13, 0x1
        je .ok_end
        jmp .err_end

    .err_end:
        xor rax, rax
        jmp .end

    .ok_end:
        mov rax, 0x1
        ; Reset the NULL we erased!
        mov BYTE [rdx], 0x0

    .end:
        pop r13
        pop r12
        pop r11
        pop rdx
        pop rcx
        pop rdi

        add rsp, 32
        pop rbp

        ret

string_len:
    ; RSI -> Pointer to the string
    push rbp
    mov rbp, rsp
    sub rsp,32

    push rbx
    push rcx

    xor rax, rax

    .loop:
        lea rcx, [rsi + rax]
        mov bl, BYTE [rcx]
        ; cmp bl, 0x0
        test bl, bl
        je .end
        inc rax
        jmp .loop

    .end:
        pop rcx
        pop rbx
        add rsp, 32
        pop rbp

        ret

validate_id:
    ; RCX -> Address of the string to validate
    ; DL -> Needed first character
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi
    push rsi
    push rcx

    mov al, BYTE [rcx]
    cmp al, dl
    jne .id_err_a

    lea rdi, [rcx + 0x1]
    call atoi

    ; Check if the 7 last digits are indeed a number!
    cmp rax, 0xFFFFFFFFFFFFFFFF
    je .id_err_c
    mov rsi, rcx
    call string_len
    cmp rax, 0x8
    jne .id_err_b
    jmp .ok_end

    .id_err_a:
        mov rdi, QWORD id_err_msg_a
        call print_string_new
        jmp .err_end

    .id_err_b:
        mov rdi, QWORD id_err_msg_b
        call print_string_new
        jmp .err_end

    .id_err_c:
        mov rdi, QWORD id_err_msg_c
        call print_string_new
        jmp .err_end

    .err_end:
        xor rax, rax
        jmp .end

    .ok_end:
        mov rax, 0x1 

    .end:
        pop rcx
        pop rsi
        pop rdi

        add rsp, 32
        pop rbp

        ret

validate_date:
    ; Pointer to the current date comes in RDI

    ; Create a stack frame
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rcx
    push rdx
    push rsi
    push rdi
    push r8
    push r9
    push r10
    push r11

    ; Number of elements read
    xor r11, r11

    mov rsi, rdi
    call string_len
    cmp rax, 0xA
    jne .err_end

    xor rax, rax

    mov rcx, rdi
    mov rdx, rdi

    .loop:
        mov al, BYTE [rdx]
        ; '/' == 0x2F
        cmp al, 0x2F
        je .get_number
        cmp al, 0x00
        je .get_number_null
        inc rdx
        jmp .loop

    .get_number_null:
        cmp r11, 0x2
        jne .err_end

    .get_number:
        mov BYTE [rdx], 0x0
        mov rdi, rcx
        call atoi
        cmp rax, 0xFFFFFFFFFFFFFFFF
        je .err_end
        cmp r11, 0x0
        je .get_day
        cmp r11, 0x1
        je .get_month
        cmp r11, 0x2
        je .get_year
        jmp .err_end

    .get_day:
        cmp rax, 0x1
        jl .err_end
        mov r8, rax
        jmp .loop_reentry

    .get_month:
        cmp rax, 0x1
        jl .err_end
        cmp rax, 12
        jg .err_end
        mov r9, rax
        jmp .loop_reentry

    .get_year:
        cmp rax, 0x1
        jl .err_end
        cmp rax, 9999
        jg .err_end
        mov r10, rax
        jmp .verify_date

    .loop_reentry:
        inc r11
        mov BYTE [rdx], 0x2F
        lea rcx, [rdx + 1]
        inc rdx
        jmp .loop

    .verify_date:
        cmp r9, 1
        je .verify_31_day
        cmp r9, 2
        je .verify_28_day
        cmp r9, 3
        je .verify_31_day
        cmp r9, 4
        je .verify_30_day
        cmp r9, 5
        je .verify_31_day
        cmp r9, 6
        je .verify_30_day
        cmp r9, 7
        je .verify_31_day
        cmp r9, 8
        je .verify_31_day
        cmp r9, 9
        je .verify_30_day
        cmp r9, 10
        je .verify_31_day
        cmp r9, 11
        je .verify_30_day
        cmp r9, 12
        je .verify_31_day
        jmp .err_end

    .verify_31_day:
        cmp r8, 31
        jg .err_end
        jmp .ok_end

    .verify_30_day:
        cmp r8, 30
        jg .err_end
        jmp .ok_end

    .verify_28_day:
        cmp r8, 29
        je .leap_year
        cmp r8, 28
        jg .err_end
        jmp .ok_end

    .leap_year:
        xor rdx, rdx
        mov rax, r10
        mov rcx, 0x4
        div rcx
        cmp rdx, 0x0
        jne .err_end
        mov rax, r10
        mov rcx, 100
        div rcx
        cmp rdx, 0x0
        je .check_400
        jmp .ok_end
        .check_400:
            mov rax, r10
            mov rcx, 400
            div rcx
            cmp rdx, 0x0
            je .ok_end
            jmp .err_end

    .err_end:
        mov rdi, QWORD date_err_msg
        call print_string_new
        xor rax, rax
        jmp .end

    .ok_end:
        mov rax, 0x1

    .end:
        pop r11
        pop r10
        pop r9
        pop r8
        pop rdi
        pop rsi
        pop rdx
        pop rcx

        add rsp, 32
        pop rbp

        ret

find_record:
    ; RSI -> String to test against
    ; RDI -> Initial address to begin searching. Return the record's address
    ; R8 -> Pointer Increment
    ; R9 -> Number of records
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rbx

    xor rbx, rbx

    .loop:
        cmp r9, rbx
        je .err_end

        call strings_are_equal
        cmp rax, 0x1
        je .end

        lea rdi, [rdi + r8]

        inc rbx
        jmp .loop

    .err_end:
        xor rax, rax
    .end:
        pop rbx

        add rsp, 32
        pop rbp

        ret

clear_screen:
    ; Set the stage for the subroutine
    push rbp
    mov rbp, rsp
    sub rsp,32

    ; Save the context of the registers we'll employ
    push rbx
    push rcx
    push rdx
    push rdi

    ; Fork the process
    mov rax, sys_fork
    int 0x80

    ; Condition ->
    ; Kid -> Returned value is 0
    ; Dad -> Returned value is NOT 0
    cmp rax, 0
    je .kid
    cmp rax, 0
    jne .dad

    .kid:
        ; Remember we won't come back from execve(); we need no more code after the call!
        ; Args ->
        ; RAX -> Entrypoint
        ; RBX -> Address of program to execute
        ; RCX -> argv (0 == NULL)
        ; RDX -> envp (0 == NULL)
        mov rax, sys_execve
        mov rbx, cls
        mov rcx, 0
        mov rdx, 0
        int 0x80

    .dad:
        ; Wait till the kid finishes with a wait()
        ; NOTE -> wait(NULL) == waitpid(-1, NULL, 0)
        mov rax, sys_waitpid
        mov rbx, -1
        mov rcx, 0
        mov rdx, 0
        int 0x80

    ; Return zero on RAX if everything went well
    xor rax, rax

    ; Reset the stack
    pop rbx
    pop rcx
    pop rdx
    pop rdi

    ; Reset everything to the way it was
    add rsp, 32
    pop rbp
    ret
%endif