; Miscellaneous subroutines implementing several common functionalities

; We'll be including the output messages so that we can provide valuable feedback to the user.
    ; Please refer to the main.asm file for an explanation on why we use the DCKR macro.
%ifdef DCKR
    %include "output_msgs.asm"
%else
    %include "/home/malware/mw_repo/management_system/output_msgs.asm"
%endif

; As we'll be %including this file more than once we need to employ the "macro trick". Please refer
    ; to output_msgs.asm for a more comprehensive explanation of the technique.
%ifndef MISC_SUBS
    %define MISC_SUBS
section .text

validate_ip:
    ; Input paramters:
        ; RDI -> Pointer to the string containing the IP address to be validated

    ; Return value:
        ; RAX ->
            ; 0x0 -> The IP address pointed to by RDI IS NOT valid
            ; 0x1 -> The IP address pointed to by RDI IS valid

    ; Create a stack frame
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; Push all the registers we'll use so that the caller can be sure it's register
        ; state won't change after the call
    push rdi
    push rcx
    push rdx
    push r11
    push r12

    ; Register breakdown:
        ; AL -> 8-bit addressing of RAX. It'll hold the string character we're currently analyzing.
        ; RDX -> It'll contain a pointer to the incoming string and will be incremented until we find
                    ; a dot ('.') so that we can pop-out the IP's octect values
        ; R11 -> Number of read octects
        ; R12 -> Flag telling us if we have detected an octect by reading a NULL character instead of a
                    ; dot ('.')

    ; Initialize the registers. Note we'll call some other I/O functions so we'll need to use
        ; RDI ourselves. That's why we save the input address on RCX so that we can later
        ; reference it. We are also zeroing RAX so that we know we are loading character
        ; values into a "clean" register. You never know...
    mov rcx, rdi
    mov rdx, rdi
    xor rax, rax
    xor r11, r11
    xor r12, r12

    .loop:
        ; Read the character currently pointed to by RDX. Note the BYTE keyword makes us
            ; read only a BYTE instead of a QWORD. That's crucial as we are interested in
            ; only analyzing individual characters.
        mov al, BYTE [rdx]

        ; Check if the character we read is a dot ('.' == 0x2E)
        cmp al, 0x2E
        ; If it is, check if it's a valid octect value
        je .validate_octect
        ; If on the other hand it's a NULL character (string termination)
        cmp al, 0x0
        ; Validate the octect too but set the "found NULL" flag in R12
        je .validate_octect_null
        ; If we haven't found a terminating character just move RDX to the next byte
            ; and inconditionally jump to the beginning of the loop again.
        inc rdx
        jmp .loop

    ; If we terminated the octect by reading a NULL character just set the "found NULL" flag
    .validate_octect_null:
        mov r12, 0x1

    .validate_octect:
        ; Swap the dot ('.') by a NULL character (NULL == 0x0) so that we can call the
            ; atoi I/O function on the octect. Remember atoi needs to find a NULL delimiting
            ; teh string to try and convert to an integer.
        mov BYTE [rdx], 0x0
        ; Store the address pointing at the beginning of the octect in RDI for calling
            ; atoi as that where it expects to find teh pointer to the string. This is why
            ; we need to use 2 registers as pointers: one needs to walk the string until it
            ; finds a dot or NULL and the other one needs to retain the address where the
            ; octect really begins!
        mov rdi, rcx
        call atoi
        ; If the result is NOT a number just quit saying the IP is NOT valid
        cmp rax, 0xFFFFFFFFFFFFFFFF
        je .err_end
        ; Do the same if the octect is lower than 0
        cmp rax, 0x0
        jl .err_end
        ; And if it's larger than 255
        cmp rax, 0xFF
        jg .err_end
        ; If the octect is valid we need to swap the NULL we added by the dot again
        mov BYTE [rdx], 0x2E
        ; Increment the valid octect count
        inc r11
        ; Check if we already have the four valid octects we need and if we do try to run
            ; the final check on the IP address. If we have more than 4 octects then the
            ; IP address is NOT valid (we assume IPv4) and we'll quit with an error. This
            ; final jump to .err_end should never take place actually but we added it just
            ; to be safe in case something work's a little different than expected as it only
            ; meant adding one more code line.
        cmp r11, 0x4
        je .check_ok
        jg .err_end
        ; If we still don't have 4 octects just move both pointers to the beginning of the
            ; next octect and begin the loop once again
        lea rcx, [rdx + 1]
        inc rdx
        jmp .loop

    .check_ok:
        ; We'll only jump here once we have 4 valid octects. If the last one was delimited by
            ; a NULL charcter (as shown by the "found NULL" flag in R12) we can then say
            ; we have a valid IP address and signal that to the caller. If the foruth octect
            ; was NOT delimited by a NULL we have something more than 4 octects and so we need
            ; to quit with an error.
        cmp r12, 0x1
        je .ok_end
        jmp .err_end

    .err_end:
        ; Just zero out RAX to signal the caller the IP pointed to by RDI is NOT valid
            ; and quit the function
        xor rax, rax
        jmp .end

    .ok_end:
        ; If the IP is valid set RAX to 1. Don't forget to reset the NULL we forcibly
            ; set to a dot within the .validate_octect tag.
        mov rax, 0x1
        mov BYTE [rdx], 0x0

    .end:
        ; Just recover the context we saved
        pop r12
        pop r11
        pop rdx
        pop rcx
        pop rdi

        ; Reset the stack frame and return
        add rsp, 32
        pop rbp

        ret

string_len:
    ; RSI -> Pointer to the string
    push rbp
    mov rbp, rsp
    sub rsp,32

    push rbx
    push rcx

    xor rax, rax

    .loop:
        lea rcx, [rsi + rax]
        mov bl, BYTE [rcx]
        ; cmp bl, 0x0
        test bl, bl
        je .end
        inc rax
        jmp .loop

    .end:
        pop rcx
        pop rbx
        add rsp, 32
        pop rbp

        ret

validate_id:
    ; RCX -> Address of the string to validate
    ; DL -> Needed first character
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rdi
    push rsi
    push rcx

    mov al, BYTE [rcx]
    cmp al, dl
    jne .id_err_a

    lea rdi, [rcx + 0x1]
    call atoi

    ; Check if the 7 last digits are indeed a number!
    cmp rax, 0xFFFFFFFFFFFFFFFF
    je .id_err_c
    mov rsi, rcx
    call string_len
    cmp rax, 0x8
    jne .id_err_b
    jmp .ok_end

    .id_err_a:
        mov rdi, QWORD id_err_msg_a
        call print_string_new
        jmp .err_end

    .id_err_b:
        mov rdi, QWORD id_err_msg_b
        call print_string_new
        jmp .err_end

    .id_err_c:
        mov rdi, QWORD id_err_msg_c
        call print_string_new
        jmp .err_end

    .err_end:
        xor rax, rax
        jmp .end

    .ok_end:
        mov rax, 0x1 

    .end:
        pop rcx
        pop rsi
        pop rdi

        add rsp, 32
        pop rbp

        ret

validate_date:
    ; Pointer to the current date comes in RDI

    ; Create a stack frame
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rcx
    push rdx
    push rsi
    push rdi
    push r8
    push r9
    push r10
    push r11

    ; Number of elements read
    xor r11, r11

    mov rsi, rdi
    call string_len
    cmp rax, 0xA
    jne .err_end

    xor rax, rax

    mov rcx, rdi
    mov rdx, rdi

    .loop:
        mov al, BYTE [rdx]
        ; '/' == 0x2F
        cmp al, 0x2F
        je .get_number
        cmp al, 0x00
        je .get_number_null
        inc rdx
        jmp .loop

    .get_number_null:
        cmp r11, 0x2
        jne .err_end

    .get_number:
        mov BYTE [rdx], 0x0
        mov rdi, rcx
        call atoi
        cmp rax, 0xFFFFFFFFFFFFFFFF
        je .err_end
        cmp r11, 0x0
        je .get_day
        cmp r11, 0x1
        je .get_month
        cmp r11, 0x2
        je .get_year
        jmp .err_end

    .get_day:
        cmp rax, 0x1
        jl .err_end
        mov r8, rax
        jmp .loop_reentry

    .get_month:
        cmp rax, 0x1
        jl .err_end
        cmp rax, 12
        jg .err_end
        mov r9, rax
        jmp .loop_reentry

    .get_year:
        cmp rax, 0x1
        jl .err_end
        cmp rax, 9999
        jg .err_end
        mov r10, rax
        jmp .verify_date

    .loop_reentry:
        inc r11
        mov BYTE [rdx], 0x2F
        lea rcx, [rdx + 1]
        inc rdx
        jmp .loop

    .verify_date:
        cmp r9, 1
        je .verify_31_day
        cmp r9, 2
        je .verify_28_day
        cmp r9, 3
        je .verify_31_day
        cmp r9, 4
        je .verify_30_day
        cmp r9, 5
        je .verify_31_day
        cmp r9, 6
        je .verify_30_day
        cmp r9, 7
        je .verify_31_day
        cmp r9, 8
        je .verify_31_day
        cmp r9, 9
        je .verify_30_day
        cmp r9, 10
        je .verify_31_day
        cmp r9, 11
        je .verify_30_day
        cmp r9, 12
        je .verify_31_day
        jmp .err_end

    .verify_31_day:
        cmp r8, 31
        jg .err_end
        jmp .ok_end

    .verify_30_day:
        cmp r8, 30
        jg .err_end
        jmp .ok_end

    .verify_28_day:
        cmp r8, 29
        je .leap_year
        cmp r8, 28
        jg .err_end
        jmp .ok_end

    .leap_year:
        xor rdx, rdx
        mov rax, r10
        mov rcx, 0x4
        div rcx
        cmp rdx, 0x0
        jne .err_end
        mov rax, r10
        mov rcx, 100
        div rcx
        cmp rdx, 0x0
        je .check_400
        jmp .ok_end
        .check_400:
            mov rax, r10
            mov rcx, 400
            div rcx
            cmp rdx, 0x0
            je .ok_end
            jmp .err_end

    .err_end:
        mov rdi, QWORD date_err_msg
        call print_string_new
        xor rax, rax
        jmp .end

    .ok_end:
        mov rax, 0x1

    .end:
        pop r11
        pop r10
        pop r9
        pop r8
        pop rdi
        pop rsi
        pop rdx
        pop rcx

        add rsp, 32
        pop rbp

        ret

find_record:
    ; RSI -> String to test against
    ; RDI -> Initial address to begin searching. Return the record's address
    ; R8 -> Pointer Increment
    ; R9 -> Number of records
    push rbp
    mov rbp, rsp
    sub rsp, 32

    push rbx

    xor rbx, rbx

    .loop:
        cmp r9, rbx
        je .err_end

        call strings_are_equal
        cmp rax, 0x1
        je .end

        lea rdi, [rdi + r8]

        inc rbx
        jmp .loop

    .err_end:
        xor rax, rax
    .end:
        pop rbx

        add rsp, 32
        pop rbp

        ret

clear_screen:
    ; Set the stage for the subroutine
    push rbp
    mov rbp, rsp
    sub rsp,32

    ; Save the context of the registers we'll employ
    push rbx
    push rcx
    push rdx
    push rdi

    ; Fork the process
    mov rax, sys_fork
    int 0x80

    ; Condition ->
    ; Kid -> Returned value is 0
    ; Dad -> Returned value is NOT 0
    cmp rax, 0
    je .kid
    cmp rax, 0
    jne .dad

    .kid:
        ; Remember we won't come back from execve(); we need no more code after the call!
        ; Args ->
        ; RAX -> Entrypoint
        ; RBX -> Address of program to execute
        ; RCX -> argv (0 == NULL)
        ; RDX -> envp (0 == NULL)
        mov rax, sys_execve
        mov rbx, cls
        mov rcx, 0
        mov rdx, 0
        int 0x80

    .dad:
        ; Wait till the kid finishes with a wait()
        ; NOTE -> wait(NULL) == waitpid(-1, NULL, 0)
        mov rax, sys_waitpid
        mov rbx, -1
        mov rcx, 0
        mov rdx, 0
        int 0x80

    ; Return zero on RAX if everything went well
    xor rax, rax

    ; Reset the stack
    pop rbx
    pop rcx
    pop rdx
    pop rdi

    ; Reset everything to the way it was
    add rsp, 32
    pop rbp
    ret
%endif
