; Miscellaneous functions implementing several common functionalities

%ifndef MISC_SUBS
    %define MISC_SUBS
        section .text

        validate_ip:
            ; Pointer to the current IP address comes in RDI

            ; Create a stack frame
            push rbp
            mov rbp, rsp
            sub rsp, 32

            push rdi
            push rcx
            push rdx
            push r11
            push r12
            push r13

            mov rcx, rdi
            mov rdx, rdi
            xor r11, r11
            xor r12, r12
            xor r13, r13

            .loop:
                mov al, BYTE [rdx]
                ; '.' == 0x2E
                cmp al, 0x2E
                je .validate_octect
                cmp al, 0x0
                je .validate_octect_null
                inc rdx
                jmp .loop

            .validate_octect_null:
                mov r13, 0x1

            .validate_octect:
                mov BYTE [rdx], 0x0
                mov rdi, rcx
                call atoi
                cmp rax, 0xFFFFFFFFFFFFFFFF
                je .err_end
                cmp rax, 0x0
                jl .err_end
                cmp rax, 255
                jg .err_end
                mov BYTE [rdx], 0x2E
                inc r11
                cmp r11, 0x4
                je .check_ok
                jg .err_end
                lea rcx, [rdx + 1]
                inc rdx

            .check_ok:
                ; We have 4 good octects!
                cmp r13, 0x1
                je .ok_end
                jmp .err_end

            .err_end:
                xor rax, rax
                jmp .end

            .ok_end:
                mov rax, 0x1

            .end:
                pop r13
                pop r12
                pop r11
                pop rdx
                pop rcx
                pop rdi

                add rsp, 32
                pop rbp

                ret

        string_len:
            push rbp
            mov rbp, rsp
            sub rsp,32

            push rbx
            push rcx

            xor rax, rax

            .loop:
                lea rcx, [rsi + rax]
                mov bl, BYTE [rcx]
                ; cmp bl, 0x0
                test bl, bl
                je .end
                inc rax
                jmp .loop

            .end:
                pop rcx
                pop rbx
                add rsp, 32
                pop rbp

                ret

        clear_screen:
            ; Set the stage for the subroutine
            push rbp
            mov rbp, rsp
            sub rsp,32

            ; Save the context of the registers we'll employ
            push rbx
            push rcx
            push rdx
            push rdi

            ; Fork the process
            mov rax, sys_fork
            int 0x80

            ; Condition ->
            ; Kid -> Returned value is 0
            ; Dad -> Returned value is NOT 0
            cmp rax, 0
            je .kid
            cmp rax, 0
            jne .dad

        .kid:
            ; Remember we won't come back from execve(); we need no more code after the call!
            ; Args ->
            ; RAX -> Entrypoint
            ; RBX -> Address of program to execute
            ; RCX -> argv (0 == NULL)
            ; RDX -> envp (0 == NULL)
            mov rax, sys_execve
            mov rbx, cls
            mov rcx, 0
            mov rdx, 0
            int 0x80

        .dad:
            ; Wait till the kid finishes with a wait()
            ; NOTE -> wait(NULL) == waitpid(-1, NULL, 0)
            mov rax, sys_waitpid
            mov rbx, -1
            mov rcx, 0
            mov rdx, 0
            int 0x80

            ; Return zero on RAX if everything went well
            xor rax, rax

            ; Reset the stack
            pop rbx
            pop rcx
            pop rdx
            pop rdi

            ; Reset everything to the way it was
            add rsp, 32
            pop rbp
            ret
%endif